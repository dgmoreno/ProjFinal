@*
    Exemplo integrado que usa as funções do controller Api/AgentesController.cs

    Para listar (GetAgentes()) e adicionar (PostAgentes(Agentes agente)) Agentes.
*@


@{
    ViewBag.Title = "Listagem e adição de Agentes via AJAX + JSON + Web API";
}

<h2>Listagem e adição de Agentes via AJAX + JSON + Web API</h2>

<div class="container">
    @*
        Container da grelha de agentes.
        Irá conter os divs com informação sobre agentes.
    *@
    <div class="row" id="grelha-categorias"></div>
</div>

@section scripts {
    @* Linha horizontal. *@
    <hr />

    <div class="hidden">
        @*
            "Template" HTML de um agente.

            Em vez de construir o HTML todo manualmente
            através de JavaScript (document.createElement, entre outros),
            crio um "esqueleto", e uso a função "cloneNode" (ver função "divAgente")
            para criar cópias.

            Isto pode ser usado, desde que se tenha cuidado para REMOVER
            os atributos "ID" dos elementos clonados (não devem existir múltiplos elementos HTML
            com o mesmo ID).
        *@
        <div id="template-categoria" class="col-sm-3">
            @*
                Ver:
                http://getbootstrap.com/docs/3.3/components/#thumbnails
            *@
            <a href="#" class="thumbnail">
                @* Imagem do agente. *@
                <img class="img-responsive" />

                <div class="caption">
                    @* Nome do agente. *@
                    <h3></h3>

                    @* Esquadra e outras informações. *@
                    <p></p>
                </div>
            </a>
        </div>
    </div>
    @*
        Nota: o @@ abaixo é por causa do Razor, é transformado em apenas um @
        quando vai para o HTML.

        Se estivesse num ficheiro JavaScript (coisa que não fiz para estar tudo junto,
        e ser mais fácil de ler de uma só vez), não colocaria @@ nos comentários de documentação.

        ---

        # Comentários /** em JavaScript:

        O uso de @param e @returns ajuda o Visual Studio e outras ferramentas
        com IntelliSense.

        Quando eu faço
        @returns {Promise<Array<{ ID: number, Nome: string, Esquadra: string, Fotografia: string | null }>}

        Estou a dizer que a função devolve:
        - Objectos do tipo Promise<>
        - Cujo tipo de dados (no .then) é Array<>
        - Cada item do Array (definido entre <>) é um objeto ({}) com o seguinte formato:
        -- ID: número,
        -- Nome: string,
        -- Esquadra: string,
        -- Fotografia: string, ou NULL.

        ---

        #  "var" vs. "let".

        O "let" foi introduzido no ES2015 como uma nova metodologia para definir variáveis em
        JavaScript.
        Eu expliquei os detalhes no vídeo da solução do exercício da Discoteca, mas
        para ser breve, o "var" só se usa em browsers antigos. O let tem menos
        problemas, especialmente quando se fazem funções dentro de loops.
    *@

    <script>

    ///////////////////////////////////////////////////////
    // Leitura de dados
    ///////////////////////////////////////////////////////

    /**
     * Função que vai buscar uma lista de agentes.
     *
     * @@returns {Promise<Array<{ ID: number, Nome: string, Descricao: string, Imagem: string | null }>}
     */
    function getCategoria() {
        return fetch("/api/categoria", {
            headers: { 'Accept': 'application/json' }
        })
        .then(resposta => resposta.json()); // JSON dos agentes.
    }

    ///////////////////////////////////////////////////////
    // Mostrar dados no ecrã
    ///////////////////////////////////////////////////////

    /**
     * Cria um div para um agente.
     *
     * @@param {{ ID: number, Nome: string, Descricao: string, Imagem: string | null }} agente
     * @@returns {HTMLDivElement}
     */
    function divCategoria(categoria) {
        /**
         * Crio uma cópia do elemento HTML com ID "template-agente"
         * com a função "cloneNode". O "true" no "cloneNode" é para indicar
         * que quero também copiar os elementos filho.
         *
         * @@type {HTMLDivElement}
         */
        let template = document.querySelector('#template-categoria').cloneNode(true);

        // Não se permitem IDs duplicados...
        template.removeAttribute('id');

        // A partir do template, obter o <img />
        let imgCategoria = template.querySelector('img');

        // Se o Agente tiver fotografia, uso-a.
        // caso contrário, escondo a imagem.
        if (categoria.Imagem != null) {
            imgCategoria.src = `/imagens/${categoria.Imagem}`;
        } else {
            imgCategoria.classList.add('hidden');
        }

        // Defino o nome e a esquadra no template...
        template.querySelector('.caption > h3').textContent = categoria.Nome;
        template.querySelector('.caption > p').textContent = `Descricao: ${categoria.Descricao}`;

        return template;
    }

    /**
     * Cria o <div /> de um Agente, e adiciona-o à grelha
     * de agentes.
     * @@param {{ ID: number, Nome: string, Descricao: string, Imagem: string | null }} categoria
     */
    function adicionarCategoria(categoria) {
        let template = divCategoria(agente);

        let grelha = document.querySelector('#grelha-categorias');

        grelha.appendChild(template);
        }

     /**
     * Inicia o ecrã dos Agentes.
     */
    function iniciarCategorias() {
        getCategoria()
            .then(categoria => {
                let grelha = document.querySelector('#grelha-categorias');

                for (let categoria of categorias) {
                    adicionarCategoria(categoria);
                }
            })
    }

        iniciarCategorias();

    </script>

}

